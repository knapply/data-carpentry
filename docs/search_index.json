[["index.html", "Data Carpentry The Craft of Working with Data Welcome", " Data Carpentry The Craft of Working with Data Brendan Knapp and Christopher Callaghan 2020-10-03 Welcome Test &lt;- == != test &lt;- &quot;face&quot; "],["preface.html", "Preface", " Preface init "],["setup-r-and-rstudio.html", "1 R and RStudio 1.1 R 1.2 RStudio", " 1 R and RStudio 1.1 R 1.1.1 Installation https://cran.r-project.org/ 1.2 RStudio 1.2.1 Installation https://rstudio.com/products/rstudio/download/ "],["the-basics.html", "2 The Basics 2.1 R as a Calculator 2.2 Fundamental Types 2.3 Variables 2.4 Multiple Values 2.5 Functions 2.6 Documentation 2.7 Missingness and Nothingness 2.8 Predicate Functions 2.9 Vectorized Functions", " 2 The Basics &quot;Hello, World!&quot; #&gt; [1] &quot;Hello, World!&quot; 2.1 R as a Calculator 1 + 1 # addition #&gt; [1] 2 1 - 1 # subtraction #&gt; [1] 0 2 * 3 # multiplication #&gt; [1] 6 1 + 1 * 3 # combining operations #&gt; [1] 4 (1 + 1) * 3 # operator precedence #&gt; [1] 6 3 / 2 # division #&gt; [1] 1.5 # ‚Üì‚Üì pronounced &quot;modulo&quot; 3 %% 2 # division remainder #&gt; [1] 1 4 %/% 2 # integer division #&gt; [1] 2 3^2 # exponents #&gt; [1] 9 4**2 # also exponents! #&gt; [1] 16 Inf + 1 # ü§î #&gt; [1] Inf If your code doesn‚Äôt form a complete expression, then R will look for more on the next line. Here‚Äôs an example: 1 + 1 + isn‚Äôt a complete expression, so R prompt for more code on subsequent lines. You‚Äôll see something like the following: &gt; 1 + + + + If this happens, press the Esc(scape) key (you may have to click on the Console pane first) and fix your code. 2.2 Fundamental Types R has several basic data types that serve as the foundation upon which everything is built. 1 # double (short for double-precision floating-point number) #&gt; [1] 1 3.14 # also double (we can just think of them as decimals) #&gt; [1] 3.14 1L # integer (`L` for &quot;Literal&quot; or `long` integers) #&gt; [1] 1 &quot;1&quot; # character or string (kinda... we&#39;ll discuss later) #&gt; [1] &quot;1&quot; TRUE # logical (similar to `bool`s in other languages) #&gt; [1] TRUE FALSE # also logical #&gt; [1] FALSE 4i # complex (we&#39;re never going to use these) #&gt; [1] 0+4i Like most programming languages, R lets us mix comments into our code. Anything that follows # on the same line is ignored by R. Comments enable us to annotate our work or temporarily (hopefully) disable lines of code. -1 * -1000 # a negative number times a negative is positive #&gt; [1] 1000 # TRUE + FALSE # felt cute, might un-comment later ü§∑ Leverage comments to communicate with humans! They‚Äôre an opportunity for explaining what something does and (often more-importantly) why something works or is necessary. Since comments are ubiquitous, it‚Äôs worth pointing out two common conventions: # TODO(CC): CC (initials) is going to implement some behavior # FIXME(BK): BK is going to fix some problem 2.3 Variables R‚Äôs assignment operator is &lt;-. my_first_var &lt;- &quot;referring to data w/ names is handy!&quot; my_first_var #&gt; [1] &quot;referring to data w/ names is handy!&quot; We can also use = like many other languages, but we highly discourage this (especially starting out) because we use = elsewhere. If you stick to &lt;-, you‚Äôll never have to guess where you‚Äôve assigned variables or rely on context clues to predict =‚Äôs intended purpose or behavior. You should always prefer descriptive variable names so that others can more easily understand your code. Most of the time, the other person will just be you in the future. length &lt;- 2 width &lt;- 4 area &lt;- length * width area #&gt; [1] 8 2.4 Multiple Values We‚Äôll almost always need to deal with more than one value, so R let‚Äôs us c()ombine values. c(1, 2, 3, 4, 5) #&gt; [1] 1 2 3 4 5 We won‚Äôt get into the nitty-gritty details just yet, but we typically call a collection of values of the same type (homogeneous) a vector. R is special for a few reasons and having native vectors is definitely one of them. Understanding how they work is fundamental to writing good (and fast!) code. c(1, 2, 3, 4, 5, 6) # `c()` is short for &quot;combine&quot; #&gt; [1] 1 2 3 4 5 6 1:6 # `:` lets us create sequences #&gt; [1] 1 2 3 4 5 6 my_first_vector &lt;- -5:5 # we&#39;ll explain `vector`s later, my_first_vector #&gt; [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 2.5 Functions # ‚ÜìÔ∏èÔ∏è name of function sqrt(x = 16) #&gt; [1] 4 R comes with some handy variables built-in , such as letters and LETTERS. letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; #&gt; [23] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; #&gt; [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # ‚Üì parameter, formal, or argument toupper(x = letters) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; #&gt; [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì argument (always) tolower(x = LETTERS) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; #&gt; [23] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; We refer to x = letters as a named argument because we specify the parameter (x) to which we‚Äôre passing our argument (letters), but we often don‚Äôt specify the name of a parameter. tolower(letters) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; #&gt; [23] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; We can‚Äôt screw up too easily since tolower() and toupper() only have one paramter (x), but many functions can take multiple arguments. Let‚Äôs say we have a vector of unsorted_numbers: unsorted_numbers &lt;- c(3, 2, 10, 8, 1, 4, 9, 6, 5, 7) unsorted_numbers #&gt; [1] 3 2 10 8 1 4 9 6 5 7 Like most languages, R has a built-in sort() function we can use, which works like so: sort(x = unsorted_numbers) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 By default, sort() sorts in ascending order, but we oftentimes will want to sort in descending (or decreasing) order. Rather than having a separate function called sort_decreasing(), we pass an argument to sort()‚Äôs decreasing parameter. sort(x = unsorted_numbers, decreasing = TRUE) #&gt; [1] 10 9 8 7 6 5 4 3 2 1 Even though sort() has multiple parameters, we can still skip the names if we pass our arguments by position. sort(unsorted_numbers, TRUE) #&gt; [1] 10 9 8 7 6 5 4 3 2 1 Considering that x is sort()‚Äôs first parameter, and decreaing is sort()‚Äôs second parameter, we can pass our arguments (unsorted_numbers and TRUE) in the same order and R will know what we meant. We can also mix positional and named argument (and often do), but we should always prioritize readable code. sort(unsorted_numbers, decreasing = TRUE) # good #&gt; [1] 10 9 8 7 6 5 4 3 2 1 sort(x = unsorted_numbers, TRUE) # avoid this #&gt; [1] 10 9 8 7 6 5 4 3 2 1 sort(decreasing = TRUE, unsorted_numbers) # just... no #&gt; [1] 10 9 8 7 6 5 4 3 2 1 2.6 Documentation You‚Äôre hopefully wondering ‚ÄúHow could we know the order of sort()‚Äôs parameters?‚Äù which leads us to documentation. If you want more information on a specific function, you should check out the documentation, which you can do with ? or help(). Here‚Äôs what that looks like for sort() ?sort help(sort) # does the same thing as `?sort` There‚Äôs a ton of information here, but all we‚Äôre interested in at the moment is the order in which we need to pass arguments to sort(), which we can find in the Arguments section. 2.7 Missingness and Nothingness 2.7.1 NA You may have noticed the na.last argument in sort()‚Äôs documentation. R can represent nothingness with NULL (same as null or None in other languages), but it can also represent unknown or missing values with NA. unsorted_numbers_with_nas &lt;- c(3, 2, 10, 8, NA, 1, 4, 9, NA, 6, 5, 7) unsorted_numbers_with_nas #&gt; [1] 3 2 10 8 NA 1 4 9 NA 6 5 7 sort()‚Äôs default behavior is na.last = NA, which simply removes any NAs. sort(unsorted_numbers_with_nas) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 If we want to keep NAs, we must specify whether sort() places them first or last. sort(unsorted_numbers_with_nas, na.last = TRUE) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 NA NA sort(unsorted_numbers_with_nas, na.last = FALSE) #&gt; [1] NA NA 1 2 3 4 5 6 7 8 9 10 2.7.2 NULL For the moment, think of the difference between NA and NULL as being that vectors (like unsorted_numbers_with_nas) can have NA values but they cannot have NULL values. If we try to put NULL in a vector, it simply disappears. c(3, 2, 10, 8, NULL, 1, 4, 9, NULL, 6, 5, 7) #&gt; [1] 3 2 10 8 1 4 9 6 5 7 But, how do we check if something is NA or NULL? 2.8 Predicate Functions A predicate function is a function that returns either TRUE or FALSE based on some condition the function is checking. Predicate functions should use a name that expresses this intent, such as is&lt;some condition&gt;, any&lt;some condition&gt;(), or all&lt;some condition&gt;(). If we want check if something is NULL, we use is.null(). is.null(&quot;this string isn&#39;t NULL!&quot;) #&gt; [1] FALSE is.null(NULL) #&gt; [1] TRUE R has many built-in predicate functions, including ones to check the basic data types that we‚Äôve already seen. is.double(1) #&gt; [1] TRUE is.double(1L) #&gt; [1] FALSE vec_dbl &lt;- c(8, 6, 7, 5, 3, 0, 9) is.double(vec_dbl) #&gt; [1] TRUE is.integer(1) #&gt; [1] FALSE is.integer(1L) #&gt; [1] TRUE vec_int &lt;- 1:10 is.integer(vec_int) #&gt; [1] TRUE is.character(3.14) #&gt; [1] FALSE is.character(&quot;is it though?&quot;) #&gt; [1] TRUE is.character(letters) #&gt; [1] TRUE is.logical(&quot;the year 2020&quot;) #&gt; [1] FALSE is.logical(TRUE) #&gt; [1] TRUE is.logical(FALSE) #&gt; [1] TRUE vec_lgl &lt;- c(TRUE, FALSE, TRUE) is.logical(vec_lgl) #&gt; [1] TRUE Similar to is.null(), there‚Äôs is.na(). is.na(&quot;not NA!&quot;) #&gt; [1] FALSE is.na(NA) #&gt; [1] TRUE Recall our variable unsorted_numbers_with_nas. unsorted_numbers_with_nas #&gt; [1] 3 2 10 8 NA 1 4 9 NA 6 5 7 Consider the following: The predicate functions we‚Äôve seen so far return either TRUE or FALSE. vectors can contain both NA and non-NA values. Can you guess what is.na() returns? is.na(unsorted_numbers_with_nas) #&gt; [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE We‚Äôll discuss accessing a vector‚Äôs individual elements later, but is.na() is what we call a vectorized function: a function that takes vector argument and operates on every element simultaneously. 2.9 Vectorized Functions As high-speed R coders, we should prefer vectorized solutions whenever possible as they‚Äôre not only idiomatic (and thus easy for other R users to understand), but they‚Äôre typically several orders of magnitude faster than other solutions. While R isn‚Äôt the fastest language out there, complaints about its speed usually come from poor code, including code that ‚Äúspeaks‚Äù R with a C or Python accent. The simplest way to wrap our heads around vectorized operations is with math. let‚Äôs first make a vector with five 0s in it. We could do that like the following: c(0, 0, 0, 0, 0) #&gt; [1] 0 0 0 0 0 But, good coders are lazy and want to (correctly) automate everything they can. With that in mind, let‚Äôs rep()eat 0 5 times. zeros &lt;- rep(0, length = 5) zeros #&gt; [1] 0 0 0 0 0 For our purposes, the term scalar refers to an object that is a single value. If we want to add 1 (a scalar) to every element of zeros, we can run zeros + 1 or 1 + zeros: zeros + 1 #&gt; [1] 1 1 1 1 1 R knows that 1 is a single value (and assumes we know what we‚Äôre doing) and performs the operation (+) between it and every element of zeros. In R-speak, we refer to this behavior as recycling. Let‚Äôs see what happens when we add zeros and a vector containing two elements. two_threes &lt;- c(3, 3) zeros + two_threes #&gt; Warning in zeros + two_threes: longer object length is not a multiple of shorter object length #&gt; [1] 3 3 3 3 3 That‚Äôs probably not what you expected and R gives us a warning() to tell us something seems wrong. R let‚Äôs us get away with a lot of things it shouldn‚Äôt, which includes "],["tabular-data.html", "3 Tabular Data 3.1 Basics 3.2 Common Pitfalls", " 3 Tabular Data Aliases: Tabular files Flat Delimited Includes: Comma-Separated Value (.csv) Tab-Separated Value (.tsv) 3.1 Basics library(readr) Here‚Äôs some example data, modified from http://www.gapminder.org/data/ country,continent,year,lifeExp,pop,gdpPercap # header/column names, separated by commas Afghanistan,Asia,1952,28.801,8425333,779.4453145 Afghanistan,Asia,1957,30.332,9240934,820.8530296 # comma-separated values Afghanistan,Asia,1962,31.997,10267083,853.10071 Afghanistan,Asia,1967,34.02,11537966,836.1971382 Afghanistan,Asia,1972,36.088,13079460,739.9811058 Afghanistan,Asia,1977,38.438,14880372,786.11336 Afghanistan,Asia,1982,39.854,12881816,978.0114388 Afghanistan,Asia,1987,40.822,13867957,852.3959448 csv_text &lt;- &#39;country,continent,year,lifeExp,pop,gdpPercap Afghanistan,Asia,1952,28.801,8425333,779.4453145 Afghanistan,Asia,1957,30.332,9240934,820.8530296 Afghanistan,Asia,1962,31.997,10267083,853.10071 Afghanistan,Asia,1967,34.02,11537966,836.1971382 Afghanistan,Asia,1972,36.088,13079460,739.9811058 Afghanistan,Asia,1977,38.438,14880372,786.11336 Afghanistan,Asia,1982,39.854,12881816,978.0114388 Afghanistan,Asia,1987,40.822,13867957,852.3959448&#39; csv_file &lt;- tempfile(fileext = &quot;.csv&quot;) csv_file # a temporary file path #&gt; [1] &quot;/tmp/Rtmpy5oDCc/file36157da156c3.csv&quot; writeLines(text = csv_text, con = csv_file) # write `csv_text` to `csv_file` read_csv(file = csv_file) #&gt; Parsed with column specification: #&gt; cols( #&gt; country = col_character(), #&gt; continent = col_character(), #&gt; year = col_double(), #&gt; lifeExp = col_double(), #&gt; pop = col_double(), #&gt; gdpPercap = col_double() #&gt; ) #&gt; # A tibble: 8 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. You may encounter Tab-Delimited data where values are separated by \\t instead of ,. Instead of readr::read_csv(), we can use readr::read_tsv(). tsv_text &lt;- &#39;country\\tcontinent\\tyear\\tlifeExp\\tpop\\tgdpPercap Afghanistan\\tAsia\\t1952\\t28.801\\t8425333\\t779.4453145 Afghanistan\\tAsia\\t1957\\t30.332\\t9240934\\t820.8530296 Afghanistan\\tAsia\\t1962\\t31.997\\t10267083\\t853.10071 Afghanistan\\tAsia\\t1967\\t34.02\\t11537966\\t836.1971382 Afghanistan\\tAsia\\t1972\\t36.088\\t13079460\\t739.9811058 Afghanistan\\tAsia\\t1977\\t38.438\\t14880372\\t786.11336 Afghanistan\\tAsia\\t1982\\t39.854\\t12881816\\t978.0114388 Afghanistan\\tAsia\\t1987\\t40.822\\t13867957\\t852.3959448&#39; tsv_file &lt;- tempfile(fileext = &quot;.tsv&quot;) writeLines(text = tsv_text, con = tsv_file) read_tsv(file = tsv_file) #&gt; Parsed with column specification: #&gt; cols( #&gt; country = col_character(), #&gt; continent = col_character(), #&gt; year = col_double(), #&gt; lifeExp = col_double(), #&gt; pop = col_double(), #&gt; gdpPercap = col_double() #&gt; ) #&gt; # A tibble: 8 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. If we find ourselves reading delmited data that uses something other than \\t or , to separate values, we can use readr::read_delim(). pipe_separated_values_text &lt;- &#39;country|continent|year|lifeExp|pop|gdpPercap Afghanistan|Asia|1952|28.801|8425333|779.4453145 Afghanistan|Asia|1957|30.332|9240934|820.8530296 Afghanistan|Asia|1962|31.997|10267083|853.10071 Afghanistan|Asia|1967|34.02|11537966|836.1971382 Afghanistan|Asia|1972|36.088|13079460|739.9811058 Afghanistan|Asia|1977|38.438|14880372|786.11336 Afghanistan|Asia|1982|39.854|12881816|978.0114388 Afghanistan|Asia|1987|40.822|13867957|852.3959448&#39; psv_file &lt;- tempfile(fileext = &quot;.tsv&quot;) writeLines(text = pipe_separated_values_text, con = psv_file) read_delim(file = psv_file, delim = &quot;|&quot;) #&gt; Parsed with column specification: #&gt; cols( #&gt; country = col_character(), #&gt; continent = col_character(), #&gt; year = col_double(), #&gt; lifeExp = col_double(), #&gt; pop = col_double(), #&gt; `gdpPercap ` = col_double() #&gt; ) #&gt; # A tibble: 8 x 6 #&gt; country continent year lifeExp pop `gdpPercap ` #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. country,continent,year,lifeExp,pop,gdpPercap # header/column names Afghanistan,Asia,1952,28.801,8425333,779.4453145 Afghanistan,Asia,1957,30.332,9240934,820.8530296 Afghanistan,Asia,1962,31.997,10267083,853.10071 Afghanistan,Asia,1967,34.02,11537966,836.1971382 Afghanistan,Asia,1972,36.088,13079460,739.9811058 Afghanistan,Asia,1977,38.438,14880372,786.11336 Afghanistan,Asia,1982,39.854,12881816,978.0114388 Afghanistan,Asia,1987,40.822,13867957,852.3959448 Afghanistan,,,N/A,, # notice that we&#39;re missing values csv_text &lt;- &#39;country,continent,year,lifeExp,pop,gdpPercap Afghanistan,Asia,1952,28.801,8425333,779.4453145 Afghanistan,Asia,1957,30.332,9240934,820.8530296 Afghanistan,Asia,1962,31.997,10267083,853.10071 Afghanistan,Asia,1967,34.02,11537966,836.1971382 Afghanistan,Asia,1972,36.088,13079460,739.9811058 Afghanistan,Asia,1977,38.438,14880372,786.11336 Afghanistan,Asia,1982,39.854,12881816,978.0114388 Afghanistan,Asia,1987,40.822,13867957,852.3959448 Afghanistan,,,N/A,,&#39; csv_file &lt;- tempfile(fileext = &quot;.csv&quot;) writeLines(text = csv_text, con = csv_file) 3.2 Common Pitfalls 3.2.1 Incorrect Column Types data_frame_from_csv &lt;- read_csv(file = csv_file) #&gt; Parsed with column specification: #&gt; cols( #&gt; country = col_character(), #&gt; continent = col_character(), #&gt; year = col_double(), #&gt; lifeExp = col_character(), #&gt; pop = col_double(), #&gt; gdpPercap = col_double() #&gt; ) data_frame_from_csv #&gt; # A tibble: 9 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.801 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.332 9240934 821. #&gt; 3 Afghanistan Asia 1962 31.997 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.02 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.088 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.438 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.854 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.822 13867957 852. #&gt; 9 Afghanistan &lt;NA&gt; NA N/A NA NA Notice that our year column says &lt;dbl&gt;, referring to it being of type double, yet all of our year values are whole numbers. typeof(data_frame_from_csv$year) #&gt; [1] &quot;double&quot; data_frame_from_csv$year #&gt; [1] 1952 1957 1962 1967 1972 1977 1982 1987 NA We also have \"N/A\" in our lifeExp column, forcing R to interpret all lifeExp values as characters (&lt;chr&gt;). typeof(data_frame_from_csv$lifeExp) #&gt; [1] &quot;character&quot; data_frame_from_csv$lifeExp #&gt; [1] &quot;28.801&quot; &quot;30.332&quot; &quot;31.997&quot; &quot;34.02&quot; &quot;36.088&quot; &quot;38.438&quot; &quot;39.854&quot; &quot;40.822&quot; &quot;N/A&quot; 3.2.1.1 Solution read_csv( file = csv_file, col_types = cols( country = col_character(), continent = col_character(), year = col_integer(), # read `year` as `integer` lifeExp = col_double(), # read `lifeExp` as `double` pop = col_double(), gdpPercap = col_double() ), na = c(&quot;&quot;, &quot;N/A&quot;) # be explicit about how `csv_file` represents missing values ) #&gt; # A tibble: 9 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. #&gt; 9 Afghanistan &lt;NA&gt; NA NA NA NA "],["manipulating-data-frames.html", "4 Manipulating Data Frames 4.1 select() Columns 4.2 filter() Rows 4.3 arrange() Rows", " 4 Manipulating Data Frames library(tidyverse, warn.conflicts = FALSE) #&gt; ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.0 ‚îÄ‚îÄ #&gt; ‚úì ggplot2 3.3.2 ‚úì purrr 0.3.4 #&gt; ‚úì tibble 3.0.3 ‚úì dplyr 1.0.2 #&gt; ‚úì tidyr 1.1.2 ‚úì stringr 1.4.0 #&gt; ‚úì readr 1.3.1 ‚úì forcats 0.5.0 #&gt; ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() df &lt;- tibble( group = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;), a = c(1, 4, NA, 3, 5), b = c(9, NA, 8, 10, 7), c = c(TRUE, FALSE, NA, FALSE, TRUE), d = c(LETTERS[1:3], NA, LETTERS[[5]]), e = factor(1:5, labels = c(&quot;tiny&quot;, &quot;small&quot;, &quot;medium&quot;, &quot;big&quot;, &quot;huge&quot;)), f_col = c(as.Date(NA), as.Date(&quot;2020-09-23&quot;) + c(3, 2, 1, 4)), g_col = c(as.POSIXct(&quot;2020-09-23 00:00:00&quot;) + 1:4 * 60 * 60 * 24 * 1.1, NA), col_h = list(c(1, 10), c(2, NA), c(3, 8), c(4, 7), c(5, 6)), col_i = list(NULL, pi, month.abb[6:10], iris, as.matrix(mtcars)) ) df #&gt; # A tibble: 5 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 2 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 3 b NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 4 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 5 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ glimpse(df) #&gt; Rows: 5 #&gt; Columns: 10 #&gt; $ group &lt;chr&gt; &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot; #&gt; $ a &lt;dbl&gt; 1, 4, NA, 3, 5 #&gt; $ b &lt;dbl&gt; 9, NA, 8, 10, 7 #&gt; $ c &lt;lgl&gt; TRUE, FALSE, NA, FALSE, TRUE #&gt; $ d &lt;chr&gt; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, NA, &quot;E&quot; #&gt; $ e &lt;fct&gt; tiny, small, medium, big, huge #&gt; $ f_col &lt;date&gt; NA, 2020-09-26, 2020-09-25, 2020-09-24, 2020-09-27 #&gt; $ g_col &lt;dttm&gt; 2020-09-24 02:24:00, 2020-09-25 04:48:00, 2020-09-26 07:12:00, 2020-09-27 09:‚Ä¶ #&gt; $ col_h &lt;list&gt; [&lt;1, 10&gt;, &lt;2, NA&gt;, &lt;3, 8&gt;, &lt;4, 7&gt;, &lt;5, 6&gt;] #&gt; $ col_i &lt;list&gt; [NULL, 3.14, &lt;&quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;&gt;, &lt;data.frame[150 x 5]&gt;, &lt;mat‚Ä¶ 4.1 select() Columns 4.1.1 by Name df %&gt;% select(a) #&gt; # A tibble: 5 x 1 #&gt; a #&gt; &lt;dbl&gt; #&gt; 1 1 #&gt; 2 4 #&gt; 3 NA #&gt; 4 3 #&gt; 5 5 df %&gt;% select(a, c, e) #&gt; # A tibble: 5 x 3 #&gt; a c e #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fct&gt; #&gt; 1 1 TRUE tiny #&gt; 2 4 FALSE small #&gt; 3 NA NA medium #&gt; 4 3 FALSE big #&gt; 5 5 TRUE huge df %&gt;% select(b, d, f_col) #&gt; # A tibble: 5 x 3 #&gt; b d f_col #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; #&gt; 1 9 A NA #&gt; 2 NA B 2020-09-26 #&gt; 3 8 C 2020-09-25 #&gt; 4 10 &lt;NA&gt; 2020-09-24 #&gt; 5 7 E 2020-09-27 df %&gt;% select(b, c, everything()) #&gt; # A tibble: 5 x 10 #&gt; b c group a d e f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 9 TRUE a 1 A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 2 NA FALSE a 4 B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 3 8 NA b NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 4 10 FALSE b 3 &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 5 7 TRUE b 5 E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% select(b, c, everything(), -a) #&gt; # A tibble: 5 x 9 #&gt; b c group d e f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 9 TRUE a A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 NA FALSE a B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 8 NA b C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 10 FALSE b &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 7 TRUE b E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; cols_to_select &lt;- c(&quot;a&quot;, &quot;c&quot;, &quot;e&quot;) df %&gt;% select(all_of(cols_to_select)) #&gt; # A tibble: 5 x 3 #&gt; a c e #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fct&gt; #&gt; 1 1 TRUE tiny #&gt; 2 4 FALSE small #&gt; 3 NA NA medium #&gt; 4 3 FALSE big #&gt; 5 5 TRUE huge 4.1.2 by Index df %&gt;% select(1L) #&gt; # A tibble: 5 x 1 #&gt; group #&gt; &lt;chr&gt; #&gt; 1 a #&gt; 2 a #&gt; 3 b #&gt; 4 b #&gt; 5 b df %&gt;% select(1, 3, 5) #&gt; # A tibble: 5 x 3 #&gt; group b d #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 a 9 A #&gt; 2 a NA B #&gt; 3 b 8 C #&gt; 4 b 10 &lt;NA&gt; #&gt; 5 b 7 E df %&gt;% select(2, 4, 6) #&gt; # A tibble: 5 x 3 #&gt; a c e #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;fct&gt; #&gt; 1 1 TRUE tiny #&gt; 2 4 FALSE small #&gt; 3 NA NA medium #&gt; 4 3 FALSE big #&gt; 5 5 TRUE huge df %&gt;% select(2:3, everything()) #&gt; # A tibble: 5 x 10 #&gt; a b group c d e f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 9 a TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 2 4 NA a FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 3 NA 8 b NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 4 3 10 b FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 5 5 7 b TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% select(2:3, everything(), -1) #&gt; # A tibble: 5 x 9 #&gt; a b c d e f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; cols_to_select &lt;- c(1, 3, 5) df %&gt;% select(all_of(cols_to_select)) #&gt; # A tibble: 5 x 3 #&gt; group b d #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 a 9 A #&gt; 2 a NA B #&gt; 3 b 8 C #&gt; 4 b 10 &lt;NA&gt; #&gt; 5 b 7 E cols_to_select &lt;- c(1, 3, 5, 1000) df %&gt;% select(any_of(cols_to_select)) #&gt; # A tibble: 5 x 3 #&gt; group b d #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 a 9 A #&gt; 2 a NA B #&gt; 3 b 8 C #&gt; 4 b 10 &lt;NA&gt; #&gt; 5 b 7 E 4.1.3 by Name Pattern contains() selects a column if any part of its name contains match=. df %&gt;% select(contains(match = &quot;col&quot;)) #&gt; # A tibble: 5 x 4 #&gt; f_col g_col col_h col_i #&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; starts_with() selects a column if its name starts with match=. df %&gt;% select(starts_with(&quot;col_&quot;)) #&gt; # A tibble: 5 x 2 #&gt; col_h col_i #&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; starts_with() selects a column if its name ends with match=. df %&gt;% select(ends_with(&quot;_col&quot;)) #&gt; # A tibble: 5 x 2 #&gt; f_col g_col #&gt; &lt;date&gt; &lt;dttm&gt; #&gt; 1 NA 2020-09-24 02:24:00 #&gt; 2 2020-09-26 2020-09-25 04:48:00 #&gt; 3 2020-09-25 2020-09-26 07:12:00 #&gt; 4 2020-09-24 2020-09-27 09:36:00 #&gt; 5 2020-09-27 NA matches()s Selects a column if its name matches a regular expression pattern. df %&gt;% select(matches(&quot;(^\\\\w_)?col(_\\\\w)?&quot;)) #&gt; # A tibble: 5 x 4 #&gt; f_col g_col col_h col_i #&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; 4.1.4 by Data Type df %&gt;% select(where(is.factor)) #&gt; # A tibble: 5 x 1 #&gt; e #&gt; &lt;fct&gt; #&gt; 1 tiny #&gt; 2 small #&gt; 3 medium #&gt; 4 big #&gt; 5 huge df %&gt;% select_if(is.factor) #&gt; # A tibble: 5 x 1 #&gt; e #&gt; &lt;fct&gt; #&gt; 1 tiny #&gt; 2 small #&gt; 3 medium #&gt; 4 big #&gt; 5 huge df %&gt;% select(where(is.factor), f_col) #&gt; # A tibble: 5 x 2 #&gt; e f_col #&gt; &lt;fct&gt; &lt;date&gt; #&gt; 1 tiny NA #&gt; 2 small 2020-09-26 #&gt; 3 medium 2020-09-25 #&gt; 4 big 2020-09-24 #&gt; 5 huge 2020-09-27 df %&gt;% select(a, !where(is.integer)) #&gt; # A tibble: 5 x 10 #&gt; a group b c d e f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 a 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 2 4 a NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 3 NA b 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 4 3 b 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 5 5 b 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% select(where(is.character) | where(is.factor)) #&gt; # A tibble: 5 x 3 #&gt; group d e #&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; #&gt; 1 a A tiny #&gt; 2 a B small #&gt; 3 b C medium #&gt; 4 b &lt;NA&gt; big #&gt; 5 b E huge df %&gt;% select(where(~ is.double(.) | is.list(.))) #&gt; # A tibble: 5 x 6 #&gt; a b f_col g_col col_h col_i #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 9 NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 4 NA 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 NA 8 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2]&gt; &lt;chr [5]&gt; #&gt; 4 3 10 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó 5]&gt; #&gt; 5 5 7 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó 11]&gt; df %&gt;% select_if(~ is.character(.x) | is.factor(.x)) #&gt; # A tibble: 5 x 3 #&gt; group d e #&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; #&gt; 1 a A tiny #&gt; 2 a B small #&gt; 3 b C medium #&gt; 4 b &lt;NA&gt; big #&gt; 5 b E huge 4.2 filter() Rows 4.2.1 by row_number() df %&gt;% filter(row_number() == 1) #&gt; # A tibble: 1 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; df %&gt;% filter(row_number() &gt; 1) #&gt; # A tibble: 4 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 2 b NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 3 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 4 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ 4.2.2 by Name df %&gt;% filter(a == 2) #&gt; # A tibble: 0 x 10 #&gt; # ‚Ä¶ with 10 variables: group &lt;chr&gt;, a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;lgl&gt;, d &lt;chr&gt;, e &lt;fct&gt;, f_col &lt;date&gt;, #&gt; # g_col &lt;dttm&gt;, col_h &lt;list&gt;, col_i &lt;list&gt; df %&gt;% filter(a != 2) #&gt; # A tibble: 4 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 3 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 4 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter(c) #&gt; # A tibble: 2 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter(!c) #&gt; # A tibble: 2 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 2 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó ‚Ä¶ df %&gt;% filter(a == 5, d == &quot;E&quot;) #&gt; # A tibble: 1 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter(a &gt;= 3 | f_col == &quot;2020-09-24&quot;) #&gt; # A tibble: 3 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 2 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2]&gt; &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 3 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter(a &lt; 2 | c) #&gt; # A tibble: 2 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter(!is.na(a), !is.na(b), !is.na(d)) #&gt; # A tibble: 2 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ 4.2.3 by Type df %&gt;% filter(across(where(is.numeric), ~ .x &gt;= 5)) #&gt; # A tibble: 1 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter_if(is.numeric, ~ .x &gt;= 5) #&gt; # A tibble: 1 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2]&gt; &lt;dbl[,11] [32 √ó‚Ä¶ df %&gt;% filter_if(is.list, ~ map_lgl(.x, ~ !is.null(.x))) #&gt; # A tibble: 4 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 2 b NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; #&gt; 3 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 4 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ 4.3 arrange() Rows df %&gt;% arrange(a) #&gt; # A tibble: 5 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 2 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 3 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 4 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ #&gt; 5 b NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; df %&gt;% arrange(desc(a)) #&gt; # A tibble: 5 x 10 #&gt; group a b c d e f_col g_col col_h col_i #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;fct&gt; &lt;date&gt; &lt;dttm&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 b 5 7 TRUE E huge 2020-09-27 NA &lt;dbl [2‚Ä¶ &lt;dbl[,11] [32 √ó‚Ä¶ #&gt; 2 a 4 NA FALSE B small 2020-09-26 2020-09-25 04:48:00 &lt;dbl [2‚Ä¶ &lt;dbl [1]&gt; #&gt; 3 b 3 10 FALSE &lt;NA&gt; big 2020-09-24 2020-09-27 09:36:00 &lt;dbl [2‚Ä¶ &lt;df[,5] [150 √ó ‚Ä¶ #&gt; 4 a 1 9 TRUE A tiny NA 2020-09-24 02:24:00 &lt;dbl [2‚Ä¶ &lt;NULL&gt; #&gt; 5 b NA 8 NA C medium 2020-09-25 2020-09-26 07:12:00 &lt;dbl [2‚Ä¶ &lt;chr [5]&gt; "],["spatial-data.html", "5 Spatial Data 5.1 geometry", " 5 Spatial Data packages &lt;- c( &quot;leaflet&quot;, # interactive web mapping &quot;osmdata&quot;, # Open Street Maps API data &quot;raster&quot;, # obtaining administrative boundary data and spatial raster data handling &quot;sf&quot;, # spatial vector data handling &quot;stars&quot;, # {sf}&#39;s spatio-temporal raster counterpart &quot;tidyverse&quot; # data manipulation ) install.packages( packages[!sapply(packages, requireNamespace, quietly = TRUE)] ) library(leaflet) library(sf) #&gt; Linking to GEOS 3.7.1, GDAL 2.4.2, PROJ 5.2.0 library(stars) #&gt; Loading required package: abind library(tidyverse) #&gt; ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.0 ‚îÄ‚îÄ #&gt; ‚úì ggplot2 3.3.2 ‚úì purrr 0.3.4 #&gt; ‚úì tibble 3.0.3 ‚úì dplyr 1.0.2 #&gt; ‚úì tidyr 1.1.2 ‚úì stringr 1.4.0 #&gt; ‚úì readr 1.3.1 ‚úì forcats 0.5.0 #&gt; ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 5.1 geometry Spatial vector data represent the world as a collection of points which, for two-dimensional data, are stored as \\(x\\) and \\(y\\) coordinates. Points can be joined in order to make lines, which themselves can be joined to make polygons. practice_coords &lt;- tibble(lng = c(-20, -20, -10, -10, 20, 20, 10, 10), lat = c(-20, 10, 20, -10, -10, 10, 20, -20), lab = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;), grp = c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;)) practice_coords #&gt; # A tibble: 8 x 4 #&gt; lng lat lab grp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 -20 -20 A a #&gt; 2 -20 10 B a #&gt; 3 -10 20 C a #&gt; 4 -10 -10 D a #&gt; 5 20 -10 E b #&gt; 6 20 10 F b #&gt; 7 10 20 G b #&gt; 8 10 -20 H b 5.1.0.1 POINT POINT refers to the location of a single point in space. Here, we use st_as_sf() to convert a regular data.frame into an sf object. Steps: take practice_coords convert to sf object with st_as_sf(), providing a character vector indicating the names of practice_coords in \\((x, y)\\) / \\((longitude, latitude)\\) order mutate() to a add a column named shape, which we obtain using st_geometry_type(). point_sf &lt;- practice_coords %&gt;% # Step 1. st_as_sf(coords = c(&quot;lng&quot;, &quot;lat&quot;)) %&gt;% # 2. mutate(shape = st_geometry_type(geometry)) # 3. point_sf #&gt; Simple feature collection with 8 features and 3 fields #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 8 x 4 #&gt; lab grp geometry shape #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;POINT&gt; &lt;fct&gt; #&gt; 1 A a (-20 -20) POINT #&gt; 2 B a (-20 10) POINT #&gt; 3 C a (-10 20) POINT #&gt; 4 D a (-10 -10) POINT #&gt; 5 E b (20 -10) POINT #&gt; 6 F b (20 10) POINT #&gt; 7 G b (10 20) POINT #&gt; 8 H b (10 -20) POINT The data in our lng and lat columns are moved to a new geometry column. ggplot(data = point_sf) + geom_sf(aes(color = lab), size = 5, show.legend = &quot;point&quot;) + labs(title = &quot;POINT&quot;) 5.1.0.2 MULTIPOINT MULTIPOINT refers to a collection of POINTs. Steps: take point_sf using group_by(), group the rows together based on the values in their grp column summarise() each group, which combines the points of each group into a MULTIPOINT mutate() the shape column to change it to the new st_geometry_type() multi_point_sf &lt;- point_sf %&gt;% # Step 1. group_by(grp) %&gt;% # 2. summarise() %&gt;% # 3. mutate(shape = st_geometry_type(geometry)) # 4. #&gt; `summarise()` ungrouping output (override with `.groups` argument) multi_point_sf #&gt; Simple feature collection with 2 features and 2 fields #&gt; geometry type: MULTIPOINT #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 2 x 3 #&gt; grp geometry shape #&gt; * &lt;chr&gt; &lt;MULTIPOINT&gt; &lt;fct&gt; #&gt; 1 a ((-20 -20), (-20 10), (-10 -10), (-10 20)) MULTIPOINT #&gt; 2 b ((10 -20), (10 20), (20 -10), (20 10)) MULTIPOINT Instead of the 8 separate POINTs with which we started, we now have 2 rows of MULTIPOINTs, each of which contain 4 points. ggplot(data = multi_point_sf) + geom_sf(aes(color = grp), size = 5, show.legend = &quot;point&quot;) + labs(title = &quot;MULTIPOINT&quot;) 5.1.0.3 LINESTRING LINESTRING is how we represent individual lines. Steps: take multi_point_sf cast the geometry to= LINESTRING using st_cast() 3 mutate() the shape column to change it to the new st_geometry_type() linestring_sf &lt;- multi_point_sf %&gt;% # Step 1. st_cast(to = &quot;LINESTRING&quot;) %&gt;% # 2. mutate(shape = st_geometry_type(geometry)) # 3. linestring_sf #&gt; Simple feature collection with 2 features and 2 fields #&gt; geometry type: LINESTRING #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 2 x 3 #&gt; grp shape geometry #&gt; * &lt;chr&gt; &lt;fct&gt; &lt;LINESTRING&gt; #&gt; 1 a LINESTRING (-20 -20, -20 10, -10 -10, -10 20) #&gt; 2 b LINESTRING (10 -20, 10 20, 20 -10, 20 10) Now we have 2 rows that each contain a LINESTRING, which was built by connecting each point to the next. ggplot(data = linestring_sf) + geom_sf(aes(color = grp), size = 2, show.legend = &quot;line&quot;) + labs(title = &quot;LINESTRING&quot;) 5.1.0.4 MULTILINESTRING Similar to MULTIPOINTs that contain multiple points, we also have MULTILINESTRINGs. Steps: take linestring_sf summarise() the rows, combining them all into a single MULTILINESTRING mutate() the shape column to change it to the new st_geometry_type() and replace the grp column that is dropped when we summarise() without using group_by() multi_linestring_sf &lt;- linestring_sf %&gt;% # Step 1. summarise() %&gt;% # 2. mutate(shape = st_geometry_type(geometry), # 3. grp = &quot;multi&quot;) # 4. multi_linestring_sf #&gt; Simple feature collection with 1 feature and 2 fields #&gt; geometry type: MULTILINESTRING #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 1 x 3 #&gt; geometry shape grp #&gt; * &lt;MULTILINESTRING&gt; &lt;fct&gt; &lt;chr&gt; #&gt; 1 ((-20 -20, -20 10, -10 -10, -10 20), (10 -20, 10 20, 20 -10, 20 10)) MULTILINESTRING multi Now we have 2 lines embedded inside a single MULTILINESTRING row. ggplot(data = multi_linestring_sf) + geom_sf(aes(color = grp), size = 2, show.legend = &quot;line&quot;) + labs(title = &quot;MULTILINESTRING&quot;) 5.1.0.5 POLYGON POLYGONs are essentially sets of lines that close to form a ring, although POLGYONs can also contain holes. We can easily wrap a shape around any geometry using st_convex_hull() to form a convex hull polygon. Steps: take point_sf using group_by(), group the rows together based on the values in their grp column summarise() each group, combining them into MULTIPOINTs wrap the MULTIPOINTs in a polygon using st_convex_hull() mutate() the shape column to change it to the new st_geometry_type() polygon_sf &lt;- point_sf %&gt;% # Step 1. group_by(grp) %&gt;% # 2. summarise() %&gt;% # 3. st_convex_hull() %&gt;% # 4. mutate(shape = st_geometry_type(geometry)) # 5. #&gt; `summarise()` ungrouping output (override with `.groups` argument) polygon_sf #&gt; Simple feature collection with 2 features and 2 fields #&gt; geometry type: POLYGON #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 2 x 3 #&gt; grp geometry shape #&gt; * &lt;chr&gt; &lt;POLYGON&gt; &lt;fct&gt; #&gt; 1 a ((-20 -20, -20 10, -10 20, -10 -10, -20 -20)) POLYGON #&gt; 2 b ((10 -20, 10 20, 20 10, 20 -10, 10 -20)) POLYGON ggplot(data = polygon_sf) + geom_sf(aes(fill = grp), show.legend = &quot;polygon&quot;) + labs(title = &quot;POLYGON&quot;) 5.1.0.6 MULTIPOLYGON POLYGONs can also be grouped together to form MULTIPOLYGONs. Steps: take polygon_sf summarise() the rows, combining them all into a single MULTILIPOLYGON mutate() the shape column to change it to the new st_geometry_type() and replace the grp column that is dropped when we summarise() without using group_by() multi_polygon_sf &lt;- polygon_sf %&gt;% # Step 1. summarise() %&gt;% # 2. mutate(shape = st_geometry_type(geometry), # 3. grp = &quot;multi&quot;) multi_polygon_sf #&gt; Simple feature collection with 1 feature and 2 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 1 x 3 #&gt; geometry shape grp #&gt; * &lt;MULTIPOLYGON&gt; &lt;fct&gt; &lt;chr&gt; #&gt; 1 (((-20 -20, -20 10, -10 20, -10 -10, -20 -20)), ((10 -20, 10 20, 20 10, 20 ‚Ä¶ MULTIPOLY‚Ä¶ multi ggplot(data = multi_polygon_sf) + geom_sf(aes(fill = grp), show.legend = &quot;polygon&quot;) + labs(title = &quot;MULTIPOLYGON&quot;) 5.1.0.7 GEOMETRY GEOMETRY is a special geometry type. It refers to a column of mixed geometries, i.e.¬†we have multiple geometry types in our geometry column. geometry_sf &lt;- list(point_sf, multi_point_sf, linestring_sf, multi_linestring_sf, polygon_sf, multi_polygon_sf) %&gt;% map_if(~ &quot;lab&quot; %in% names(.x), select, -lab) %&gt;% do.call(what = rbind) %&gt;% mutate(grp = if_else(shape == &quot;POINT&quot;, as.character(row_number()), grp)) geometry_sf #&gt; Simple feature collection with 16 features and 2 fields #&gt; geometry type: GEOMETRY #&gt; dimension: XY #&gt; bbox: xmin: -20 ymin: -20 xmax: 20 ymax: 20 #&gt; CRS: NA #&gt; # A tibble: 16 x 3 #&gt; grp geometry shape #&gt; * &lt;chr&gt; &lt;GEOMETRY&gt; &lt;fct&gt; #&gt; 1 1 POINT (-20 -20) POINT #&gt; 2 2 POINT (-20 10) POINT #&gt; 3 3 POINT (-10 20) POINT #&gt; 4 4 POINT (-10 -10) POINT #&gt; 5 5 POINT (20 -10) POINT #&gt; 6 6 POINT (20 10) POINT #&gt; 7 7 POINT (10 20) POINT #&gt; 8 8 POINT (10 -20) POINT #&gt; 9 a MULTIPOINT ((-20 -20), (-20 10), (-10 -10), (-10 20)) MULTIPOINT #&gt; 10 b MULTIPOINT ((10 -20), (10 20), (20 -10), (20 10)) MULTIPOINT #&gt; 11 a LINESTRING (-20 -20, -20 10, -10 -10, -10 20) LINESTRING #&gt; 12 b LINESTRING (10 -20, 10 20, 20 -10, 20 10) LINESTRING #&gt; 13 multi MULTILINESTRING ((-20 -20, -20 10, -10 -10, -10 20), (10 -20, 10 20, 20 ‚Ä¶ MULTILINEST‚Ä¶ #&gt; 14 a POLYGON ((-20 -20, -20 10, -10 20, -10 -10, -20 -20)) POLYGON #&gt; 15 b POLYGON ((10 -20, 10 20, 20 10, 20 -10, 10 -20)) POLYGON #&gt; 16 multi MULTIPOLYGON (((-20 -20, -20 10, -10 20, -10 -10, -20 -20)), ((10 -20, 1‚Ä¶ MULTIPOLYGON ggplot(data = geometry_sf) + geom_sf(aes(color = grp, fill = grp), size = 2, show.legend = FALSE) + facet_wrap(~ shape, nrow = 2) + labs(title = &quot;GEOMETRY&quot;) "]]
